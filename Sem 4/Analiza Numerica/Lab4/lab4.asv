% 1.
% % Given data
% Time = [0, 3, 5, 8, 13];
% Distance = [0, 225, 383, 623, 993];
% Speed = [75, 77, 80, 74, 72];
% 
% % Time to estimate
% t = 10;
% 
% % Hermite interpolation function
% [distance_estimate, speed_estimate] = hermite_interpolation(Time, Distance, Speed, t);
% 
% % Display the results
% fprintf('Estimated position of the car at t = 10: %.2f units\n', distance_estimate);
% fprintf('Estimated speed of the car at t = 10: %.2f units/time\n', speed_estimate);

% 2.
% % Given data points
% x_values = [1, 2];
% y_values = [0, 0.6931];
% dy_values = [1, 0.5];
% x_interpolate = 1.5;
% 
% % Apply cubic interpolation
% cubic_approximation = cubic_interpolation(x_values, y_values, dy_values, x_interpolate);
% 
% % Calculate the exact value of f(1.5)
% exact_value = log(1.5);
% 
% % Calculate the absolute approximation error
% absolute_error = abs(cubic_approximation - exact_value);
% 
% % Display the results
% fprintf('Cubic interpolation approximation of f(1.5): %.4f\n', cubic_approximation);
% fprintf('Exact value of f(1.5): %.4f\n', exact_value);
% fprintf('Absolute approximation error: %.4f\n', absolute_error);

% 3.
% Define the function f(x) = sin(2x)
f = @(x) sin(2*x);

% Generate 15 equidistant nodes between -5 and 5
n = 15;
x_nodes = linspace(-5, 5, n);

% Calculate function values and derivative values at the nodes
y_nodes = f(x_nodes);
dy_nodes = 2 * cos(2 * x_nodes);

% Define the interval for plotting
x_interval = linspace(-5, 5, 1000);

% Hermite interpolation function
hermite_interpolation = @(x) hermite_polynomial(x, x_nodes, y_nodes, dy_nodes);

% Calculate Hermite interpolation polynomial values
y_hermite = hermite_interpolation(x_interval);

% Plot the original function and Hermite interpolation polynomial
figure;
plot(x_interval, f(x_interval), 'b-', 'LineWidth', 2);
hold on;
plot(x_interval, y_hermite, 'r--', 'LineWidth', 2);
scatter(x_nodes, y_nodes, 100, 'ko', 'filled');
xlabel('x');
ylabel('y');
title('Hermite Interpolation of sin(2x)');
legend('sin(2x)', 'Hermite Interpolation Polynomial', 'Equidistant Nodes', 'Location', 'best');
grid on;
hold off;

% Hermite polynomial function
function y_interpolated = hermite_polynomial(x, x_nodes, y_nodes, dy_nodes)
    n = length(x_nodes);
    y_interpolated = zeros(size(x));

    for i = 1:n
        % Construct the Hermite basis function for each node
        h = @(z, i) (1 - 2 * (z - x_nodes(i)) * poly_der(z, i)) * poly_sqr(z, i);

        % Calculate the interpolated value at each x
        y_interpolated = y_interpolated + y_nodes(i) * h(x, i);
    end
end

% Function to compute the derivative of the polynomial
function der = poly_der(x, index)
    n = length(index);
    der = zeros(size(x));

    for i = 1:n
        p = 1;
        for j = 1:n
            if j ~= index(i)
                p = p .* (x - index(j));
            end
        end
        der = der + p;
    end
end

% Function to compute the squared term of the polynomial
function sqr = poly_sqr(x, index)
    n = length(index);
    sqr = ones(size(x));

    for i = 1:n
        sqr = sqr .* (x - index(i)).^2;
    end
end
